# Fiber

React的核心算法是---reconciliation（调解器）有两个版本，之前的叫stack reconciliation 现在的叫 fiber reconciliation

原因：React 15 版本的问题

在页面元素很多，且需要频繁刷新的场景下，React V15.x 会出现掉帧的现象。 原因是大量的同步计算任务阻塞了浏览器的UI渲染。

因为在默认情况下，JS运算、页面布局、页面绘制都是运行在浏览器的主线程当中，他们之间是互斥的关系。如果JS运算持续占用主线程，页面就没法得到及时的更新。

当我们调用setState更新页面的时候，React会遍历应用的所有节点，计算出差异，然后再更新UI。整个过程是不能被打断的。如果页面元素很多，整个过程占用的时机就可能超过16ms，就容易出现掉帧的现象。

解决：

解决主线程长时间被 JS 运算占用这一问题的基本思路，是将运算切割为多个步骤，分批完成。也就是说在完成一部分任务之后，将控制权交回给浏览器，让浏览器有时间进行页面的渲染。等浏览器忙完之后，再继续之前未完成的任务。

对应的api是requestIdleCallback。

window.requestIdleCallback()会在浏览器空闲时期依次调用函数，这就可以让开发者在主事件循环中执行后台和低优先级的任务，而且不会对像动画和输入响应等用户交互这些延迟触发但关键的事件产生影响。函数一般会按先进先调用的顺序执行，除非函数在浏览器调用它之前就到了它的超时时间。

React将任务分成小片，在一小片段的时间内运行这些分片任务，让主线程做优先级更高的事情。

Fiber的拆分方案就是按照虚拟DOM拆分，因为fiber tree是根据Virtual DOM tree 构建出来的，结构上是一样的，只是节点携带的信息不一样。还包含sibling的子节点， return的父节点，把一颗树变成一外链表。

因此，每个组件实例和每个DOM节点的抽象表示都是一个工作单元，在工作循环中，每次处理一个fiber,处理完一个就会判断是否有高优先级的任务或者剩余时间是否充足，可以继续处理或者挂起或者完成工作循环。

每个节点的执行是通过调度器来进行任务分配：

每执行一段时间，都会将控制权交回给浏览器。在执行时，根据优先级来进行分配，优先级有6种

- synchronous，与之前的Stack Reconciler操作一样，同步执行
- task，在next tick之前执行
- animation，下一帧之前执行
- high，在不久的将来立即执行
- low，稍微延迟执行也没关系
- offscreen，下一次render时或scroll时才执行

在协调render阶段是可以被打断，而commit阶段是不能被打断的。